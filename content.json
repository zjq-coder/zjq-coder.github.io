[{"title":"前端学习分享","date":"2017-05-14T01:18:01.363Z","path":"2017/05/14/前端分享/","raw":"---\ntitle: 前端学习分享\ndate: \ncategories:\ntags:\n     - cookies\n     - 前端\n---\n\n####  前端学习分享\n\n1.谈谈Cookie的弊端\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=439915614&auto=1&height=66\"></iframe>\n\ncookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。\n第一：每个特定的域名下最多生成20个cookie\n1.IE6或更低版本最多20个cookie\n2.IE7和之后的版本最后可以有50个cookie。\n3.Firefox最多50个cookie\n4.chrome和Safari没有做硬性限制\nIE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。\n\n<!--more-->\n\ncookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。\nIE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。\n优点：极高的扩展性和可用性\n1.通过良好的编程，控制保存在cookie中的session对象的大小。\n2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。\n3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。\n4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。\n\n\n\n缺点：\n1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。\n\n2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。\n\n3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。\n2.浏览器本地存储\n\n在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。\nhtml5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。\nsessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。\n而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。\n3.web storage和cookie的区别\n\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。\n但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生\n浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。\nlocalStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等\nCSS 相关问题\n\ndisplay:none和visibility:hidden的区别？\ndisplay:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，\n就当他从来不存在。\n\nvisibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。\nCSS中 link 和@import 的区别是？\nA：(1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重.\nposition的absolute与fixed共同点与不同点\nA：共同点：\n1.改变行内元素的呈现方式，display被置为block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上\n\nB不同点：\nabsolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。  \n介绍一下CSS的盒子模型？\n1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;\n\n2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).\nCSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？\n   *   1.id选择器（ \n        2.类选择器（.myclassname）\n        3.标签选择器（div, h1, p）\n        4.相邻选择器（h1 + p）\n        5.子选择器（ul < li）\n        6.后代选择器（li a）\n        7.通配符选择器（ * ）\n        8.属性选择器（a[rel = \"external\"]）\n        9.伪类选择器（a: hover, li: nth - child）\n\n    *   可继承的样式： font-size font-family color, ULLIDLDDDT;\n\n    *   不可继承的样式：border padding margin width height ;\n\n    *   优先级就近原则，同权重情况下样式定义最近者为准;\n\n    *   载入样式以最后载入的定位为准;\n\n优先级为:\n\n\n   !important >  id > class > tag  \n\n   important 比 内联优先级高\n\nCSS3新增伪类举例：\n\n\np:first-of-type 选择属于其父元素的首个 \n 元素的每个 \n 元素。p:last-of-type  选择属于其父元素的最后 \n 元素的每个 \n 元素。p:only-of-type  选择属于其父元素唯一的 \n 元素的每个 \n 元素。p:only-child    选择属于其父元素的唯一子元素的每个 \n 元素。\np:nth-child(2)  选择属于其父元素的第二个子元素的每个 \n 元素。\n:enabled  :disabled 控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？\n1.   \n  block 象块类型元素一样显示。\n  none 缺省值。象行内元素类型一样显示。\n  inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。\n  list-item 象块类型元素一样显示，并添加样式列表标记。\n\n  2. \n  *absolute \n        生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 \n\n  *fixed （老IE不支持）\n        生成绝对定位的元素，相对于浏览器窗口进行定位。 \n\n  *relative \n        生成相对定位的元素，相对于其正常位置进行定位。 \n\n  * static  默认值。没有定位，元素出现在正常的流中\n  *（忽略 top, bottom, left, rightz-index 声明）。\n\n  * inherit 规定从父元素继承 position 属性的值。\nCSS3有哪些新特性？\nCSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），\n  对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）\n  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);\n  增加了更多的CSS选择器  多背景 rgba \n对BFC规范的理解？\n BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。   \n（W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关 系和相互作用。）\n解释下 CSS sprites，以及你要如何在页面或网站中使用它。\nCSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。\nhtml部分\n\n说说你对语义化的理解？\n用正确的标签做正确的事情！\nhtml语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。\n搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\nDoctype作用? 严格模式与混杂模式如何区分？它们有何意义?\n（1）、<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 \n\n（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。\n\n（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。\n\n（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。   \n你知道多少种Doctype文档类型？\n 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。\n HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。\n XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。\nStandards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks\n （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。\nHTML与XHTML——二者有什么区别\n\n区别：\n1.所有的标记都必须要有一个相应的结束标记\n2.所有标签的元素和属性的名字都必须使用小写\n3.所有的XML标记都必须合理嵌套\n4.所有的属性必须用引号\"\"括起来\n5.把所有<和&特殊符号用编码表示\n6.给所有属性赋一个值\n7.不要在注释内容中使“--”8.图片必须有说明文字\n常见兼容性问题？\n\n* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n\n* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。\n\n* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 \n\n* 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）\n  #box{ float:left; width:10px; margin:000100px;} \n\n 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)\n\n*  渐进识别的方式，从总体中逐渐排除局部。 \n\n  首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 \n  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。\n\n  css.bb{\n       background-color:#f1ee18;\n      .background-color:#00deff\\9; \n      +background-color:#a200ff;\n      _background-color:#1e0bd1; \n      } \n\n*  IE下,可以使用获取常规属性的方法来获取自定义属性,\n   也可以使用getAttribute()获取自定义属性;\n   Firefox下,只能使用getAttribute()获取自定义属性. \n   解决方法:统一通过getAttribute()获取自定义属性.\n\n* IE下,event对象有x,y属性,但是没有pageX,pageY属性; \n  Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.\n\n* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。\n\n* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, \n  可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.\n\n* 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:\nL-V-H-A :  a:link{}a:visited{}a:hover{}a:active{}\n\n* 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。\n\n* 上下margin重合问题\nie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。\n解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。\n* ie6对png图片格式支持不好(引用一段脚本处理)\n解释下浮动和它的工作原理？清除浮动的技巧\n浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。\n\n1.使用空标签清除浮动。\n   这种方法是在所有浮动标签后面添加一个空标签 定义cssclear:both. 弊端就是增加了无意义标签。\n2.使用overflow。\n   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。\n3.使用after伪对象清除浮动。\n   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；\n浮动元素引起的问题和解决办法？\n浮动元素引起的问题：\n（1）父元素的高度无法被撑开，影响与父元素同级的元素\n（2）与浮动元素同级的非浮动元素会跟随其后\n（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构\n解决方法：\n使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：\n.clearfix:after{content:\".\";display: block;height:0;clear: both;visibility: hidden;}.clearfix{display: inline-block;}\n清除浮动的几种方法：\n1，额外标签法，<divstyle=\"clear:both;\">\n（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类 content:\".\"; height:0; visibility:hidden; display:block; clear:both; }3,浮动外部元素4,设置`overflow`为`hidden`或者autoIE 8以下版本的浏览器中的盒模型有什么不同\nIE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框\nDOM操作——怎样添加、移除、移动、复制、创建和查找节点。\n（1）创建新节点\n\n      createDocumentFragment()createElement()createTextNode()   \n\n（2）添加、移除、替换、插入\n\n      appendChild()removeChild()replaceChild()insertBefore() \n\n（3）查找\n\n      getElementsByTagName()getElementsByName()getElementById()\nhtml5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\n* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n\n* 绘画 canvas  \n  用于媒介回放的 video 和 audio 元素 \n  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n  sessionStorage 的数据在浏览器关闭后自动删除\n\n  语意化更好的内容元素，比如 article、footer、header、nav、section \n  表单控件，calendar、date、time、email、url、search  \n  新的技术webworker, websockt, Geolocation\n\n* 移除的元素\n\n纯表现的元素：basefont，big，center，font, s，strike，tt，u；\n\n对可用性产生负面影响的元素：frame，frameset，noframes；\n\n支持HTML5新标签：\n\n* IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n  可以利用这一特性让这些浏览器支持HTML5新标签，\n\n  浏览器支持新标签后，还需要添加标签默认的样式：\n\n* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架\n\n如何区分： DOCTYPE声明\\新增的结构元素\\功能元素\niframe的优缺点？\n\n1.<iframe>优点：\n\n    解决加载缓慢的第三方内容如图标和广告等的加载问题\n    Security sandbox\n    并行加载脚本\n\n2.<iframe>的缺点：\n\n\n    *iframe会阻塞主页面的Onload事件；\n\n    *即时内容为空，加载也需要时间\n    *没有语意 \n如何实现浏览器内多个标签页之间的通信?\n\n调用localstorge、cookies等本地存储方式\nwebSocket如何兼容低浏览器？\n\nAdobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR\n线程与进程的区别\n\n一个程序至少有一个进程,一个进程至少有一个线程. \n线程的划分尺度小于进程，使得多线程程序的并发性高。 \n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 \n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 \n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n你如何对网站的文件和资源进行优化？\n\n期待的解决方案包括：\n 文件合并\n 文件最小化/文件压缩\n 使用 CDN 托管\n 缓存的使用（多个域名来提供缓存）\n 其他\n请说出三种减少页面加载时间的方法。\n\n1.优化图片 \n 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） \n 3.优化CSS（压缩合并css，如margin-top,margin-left...) \n 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） \n 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 \n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） \n\n6.减少http请求（合并文件，合并图片）。\n你都使用哪些工具来测试代码的性能？\n\nProfiler, JSPerf（http:\n什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？\n\n FOUC - Flash Of Unstyled Content 文档样式闪烁\n <styletype=\"text/css\"media=\"all\">@import\"../fouc.css\";</style> \n而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。\n 解决方法简单的出奇，只要在<head>之间加入一个<link>或者<script>元素就可以了。\nnull和undefined的区别？\n\nnull是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。\n当声明的变量还未被初始化时，变量的默认值为undefined。\nnull用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。\nundefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是：\n（1）变量被声明了，但没有赋值时，就等于undefined。\n\n（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n\n（3）对象没有赋值的属性，该属性的值为undefined。\n\n（4）函数没有返回值时，默认返回undefined。\nnull表示\"没有对象\"，即该处不应该有值。典型用法是：\n（1） 作为函数的参数，表示该函数的参数不是对象。\n\n（2） 作为对象原型链的终点。\nnew操作符具体干了什么呢?\n\n1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n   2、属性和方法被加入到 this 引用的对象中。\n   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\nvar obj  = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj); \nJSON 的了解？\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\n它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小\n{'age':'12', 'name':'back'}\njs延迟加载的方式有哪些？\n\ndefer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js\n如何解决跨域问题?\n\n    jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n\njsonp的原理是动态插入script标签\n具体参见：详解js跨域问题\ndocumen.write和 innerHTML的区别\n\ndocument.write只能重绘整个页面\n\ninnerHTML可以重绘页面的一部分\n.call() 和 .apply() 的区别和作用？\n\n作用：动态改变某个类的某个方法的运行环境。\n区别参见：JavaScript学习总结（四）function函数部分\n哪些操作会造成内存泄漏？\n\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\n\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n详见：详解js变量、作用域及内存\nJavaScript中的作用域与变量声明提升？\n\n详见：详解JavaScript函数模式\n如何判断当前脚本运行在浏览器还是node环境中？\n\n通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中\n其他问题？\n\n你遇到过比较难的技术问题是？你是如何解决的？常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？页面重构怎么操作？列举IE 与其他浏览器不一样的特性？99%的网站都需要被重构是那本书上写的？什么叫优雅降级和渐进增强？\n详见：css学习归纳总结（一）\nWEB应用从服务器主动推送Data到客户端有那些方式？对Node的优点和缺点提出了自己的看法？\n*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？你常用的开发工具是什么，为什么？数组去重？对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？\n前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。\n    1、实现界面交互\n    2、提升用户体验\n    3、有了Node.js，前端可以实现服务端的一些事情\n\n\n前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n\n 参与项目，快速高质量完成实现效果图，精确到1px；\n\n 与团队成员，UI设计，产品经理的沟通；\n\n 做好的页面结构，页面重构和用户体验；\n\n 处理hack，兼容、写出优美的代码格式；\n\n 针对服务器的优化、拥抱最新前端技术。\n你在现在的团队处于什么样的角色，起到了什么明显的作用？你认为怎样才是全端工程师（Full Stack developer）？介绍一个你最得意的作品吧？你的优点是什么？缺点是什么？如何管理前端团队?最近在学什么？能谈谈你未来3，5年给自己的规划吗？\n你有哪些性能优化的方法？\n\n（看雅虎14条性能优化原则）。\n\n  （1） 减少http请求次数：CSSSprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n  （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n  （4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n  （6） 避免使用CSSExpression（css表达式)又称Dynamic properties(动态属性)。\n\n  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\nhttp状态码有那些？分别代表是什么意思？\n\n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。\n500-599 用于支持服务器错误。 503 – 服务不可用\n一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\n\n 查找浏览器缓存 \n    DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求\n    进行HTTP协议会话\n    客户端发送报头(请求报头)\n    服务器回馈报头(响应报头)\n    html文档开始下载\n    文档树建立，根据标记请求所需指定MIME类型的文件\n    文件显示\n    {\n    浏览器这边做的工作大致分为以下几步：\n\n    加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。\n\n    解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）\n    }\n平时如何管理你的项目？\n\n先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；\n\n        编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n        标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n        页面进行标注（例如 页面 模块 开始和结束）；\n\n        CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；\n\n        JS 分文件夹存放 命名以该JS功能为准的英文翻译。\n\n        图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 \n说说最近最流行的一些东西吧？常去哪些网站？\n\nNode.js、Mongodb、npm、MVVM、MEAN、three.js,React 。\n网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等\njavascript对象的几种创建方式\n\n1，工厂模式\n2，构造函数模式\n3，原型模式\n4，混合构造函数和原型模式\n5，动态原型模式\n6，寄生构造函数模式\n7，稳妥构造函数模式\njavascript继承的6种方法\n\n1，原型链继承\n2，借用构造函数继承\n3，组合继承(原型+借用构造)\n4，原型式继承\n5，寄生式继承\n6，寄生组合式继承\najax过程\n\n(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.\n\n(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.\n\n(3)设置响应HTTP请求状态变化的函数.\n\n(4)发送HTTP请求.\n\n(5)获取异步调用返回的数据.\n\n(6)使用JavaScript和DOM实现局部刷新.\n异步加载和延迟加载\n\n1.异步加载的方案： 动态插入script标签\n2.通过ajax去获取js代码，然后通过eval执行\n3.script标签上添加defer或者async属性\n4.创建并插入iframe，让它异步执行js\n5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。\n前端安全问题？\n\n    （XSS，sql注入，CSRF）\nCSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。\n\n**完成CSRF需要两个步骤：**\n\n1.登陆受信任的网站A，在本地生成COOKIE\n\n2.在不登出A的情况下，或者本地COOKIE没有过期的情况下，访问危险网站B。\nie各版本和chrome可以并行下载多少个资源\n\nIE6 两个并发，iE7升级之后的6个并发，之后版本也是6个\n\nFirefox，chrome也是6个\njavascript里面的继承怎么实现，如何避免原型链上面的对象共享\n\n用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量\ngrunt， YUI compressor 和 google clojure用来进行代码压缩的用法。\n\nYUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。\n\n使用方法：\n\n//压缩JS\njava -jar yuicompressor-2.4.2.jar --type js --charset utf-8-v src.js > packed.js\n//压缩CSS\njava -jar yuicompressor-2.4.2.jar --type css --charset utf-8-v src.css > packed.css\nFlash、Ajax各自的优缺点，在使用中如何取舍？\n\n1、Flash ajax对比\nFlash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。\nAjax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。\n共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM\nGET和POST的区别，何时使用POST？\n\nGET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符\n    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。\n\n    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，\n    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\n然而，在以下情况中，请使用 POST 请求：\n无法使用缓存文件（更新服务器上的文件或数据库）\n向服务器发送大量数据（POST 没有数据量限制）\n发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n","content":"<h4 id=\"前端学习分享\"><a href=\"#前端学习分享\" class=\"headerlink\" title=\"前端学习分享\"></a>前端学习分享</h4><p>1.谈谈Cookie的弊端</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=439915614&auto=1&height=66\"></iframe>\n\n<p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br>第一：每个特定的域名下最多生成20个cookie<br>1.IE6或更低版本最多20个cookie<br>2.IE7和之后的版本最后可以有50个cookie。<br>3.Firefox最多50个cookie<br>4.chrome和Safari没有做硬性限制<br>IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。</p>\n<a id=\"more\"></a>\n<p>cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。<br>IE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。<br>优点：极高的扩展性和可用性<br>1.通过良好的编程，控制保存在cookie中的session对象的大小。<br>2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>\n<p>缺点：<br>1.<code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p>\n<p>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>\n<p>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。<br>2.浏览器本地存储</p>\n<p>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。<br>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。<br>3.web storage和cookie的区别</p>\n<p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。<br>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生<br>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。<br>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等<br>CSS 相关问题</p>\n<p>display:none和visibility:hidden的区别？<br>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，<br>就当他从来不存在。</p>\n<p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。<br>CSS中 link 和@import 的区别是？<br>A：(1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重.<br>position的absolute与fixed共同点与不同点<br>A：共同点：<br>1.改变行内元素的呈现方式，display被置为block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上</p>\n<p>B不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。<br>介绍一下CSS的盒子模型？<br>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;</p>\n<p>2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).<br>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>\n<ul>\n<li><p>1.id选择器（<br> 2.类选择器（.myclassname）<br> 3.标签选择器（div, h1, p）<br> 4.相邻选择器（h1 + p）<br> 5.子选择器（ul &lt; li）<br> 6.后代选择器（li a）<br> 7.通配符选择器（ * ）<br> 8.属性选择器（a[rel = “external”]）<br> 9.伪类选择器（a: hover, li: nth - child）</p>\n<ul>\n<li><p>可继承的样式： font-size font-family color, ULLIDLDDDT;</p>\n</li>\n<li><p>不可继承的样式：border padding margin width height ;</p>\n</li>\n<li><p>优先级就近原则，同权重情况下样式定义最近者为准;</p>\n</li>\n<li><p>载入样式以最后载入的定位为准;</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>优先级为:</p>\n<p>   !important &gt;  id &gt; class &gt; tag  </p>\n<p>   important 比 内联优先级高</p>\n<p>CSS3新增伪类举例：</p>\n<p>p:first-of-type 选择属于其父元素的首个<br> 元素的每个<br> 元素。p:last-of-type  选择属于其父元素的最后<br> 元素的每个<br> 元素。p:only-of-type  选择属于其父元素唯一的<br> 元素的每个<br> 元素。p:only-child    选择属于其父元素的唯一子元素的每个<br> 元素。<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个<br> 元素。<br>:enabled  :disabled 控制表单控件的禁用状态。<br>:checked        单选框或复选框被选中。<br>列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？</p>\n<ol>\n<li><p>block 象块类型元素一样显示。<br>none 缺省值。象行内元素类型一样显示。<br>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。<br>list-item 象块类型元素一样显示，并添加样式列表标记。</p>\n<ol>\n<li>*absolute<br>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 </li>\n</ol>\n<p>*fixed （老IE不支持）<br>   生成绝对定位的元素，相对于浏览器窗口进行定位。 </p>\n<p>*relative<br>   生成相对定位的元素，相对于其正常位置进行定位。 </p>\n<ul>\n<li><p>static  默认值。没有定位，元素出现在正常的流中<br>*（忽略 top, bottom, left, rightz-index 声明）。</p>\n</li>\n<li><p>inherit 规定从父元素继承 position 属性的值。<br>CSS3有哪些新特性？<br>CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），<br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);<br>增加了更多的CSS选择器  多背景 rgba<br>对BFC规范的理解？<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>（W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关 系和相互作用。）<br>解释下 CSS sprites，以及你要如何在页面或网站中使用它。<br>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。<br>html部分</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>说说你对语义化的理解？<br>用正确的标签做正确的事情！<br>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。<br>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。<br>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?<br>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 </html></p>\n<p>（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</p>\n<p>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>\n<p>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。<br>你知道多少种Doctype文档类型？<br> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br> HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br> XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks<br> （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。<br>HTML与XHTML——二者有什么区别</p>\n<p>区别：<br>1.所有的标记都必须要有一个相应的结束标记<br>2.所有标签的元素和属性的名字都必须使用小写<br>3.所有的XML标记都必须合理嵌套<br>4.所有的属性必须用引号””括起来<br>5.把所有&lt;和&amp;特殊符号用编码表示<br>6.给所有属性赋一个值<br>7.不要在注释内容中使“–”8.图片必须有说明文字<br>常见兼容性问题？</p>\n<ul>\n<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p>\n</li>\n<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>\n</li>\n<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </p>\n</li>\n<li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:000100px;} </p>\n<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——<em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p>\n</li>\n<li><p>渐进识别的方式，从总体中逐渐排除局部。 </p>\n<p>首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>\n<p>css.bb{</p>\n<pre><code>background-color:#f1ee18;\n</code></pre><p>   .background-color:#00deff\\9;<br>   +background-color:#a200ff;<br>   _background-color:#1e0bd1;<br>   } </p>\n</li>\n<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p>\n</li>\n<li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p>\n</li>\n<li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>\n</li>\n<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>\n</li>\n<li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link{}a:visited{}a:hover{}a:active{}</p>\n</li>\n<li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p>\n</li>\n<li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>\n</li>\n<li>ie6对png图片格式支持不好(引用一段脚本处理)<br>解释下浮动和它的工作原理？清除浮动的技巧<br>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</li>\n</ul>\n<p>1.使用空标签清除浮动。<br>   这种方法是在所有浮动标签后面添加一个空标签 定义cssclear:both. 弊端就是增加了无意义标签。<br>2.使用overflow。<br>   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>3.使用after伪对象清除浮动。<br>   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<br>浮动元素引起的问题和解决办法？<br>浮动元素引起的问题：<br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构<br>解决方法：<br>使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：<br>.clearfix:after{content:”.”;display: block;height:0;clear: both;visibility: hidden;}.clearfix{display: inline-block;}<br>清除浮动的几种方法：<br>1，额外标签法，<divstyle=\"clear:both;\"><br>（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类 content:”.”; height:0; visibility:hidden; display:block; clear:both; }3,浮动外部元素4,设置<code>overflow</code>为<code>hidden</code>或者autoIE 8以下版本的浏览器中的盒模型有什么不同<br>IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框<br>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<br>（1）创建新节点</divstyle=\"clear:both;\"></p>\n<pre><code>createDocumentFragment()createElement()createTextNode()   \n</code></pre><p>（2）添加、移除、替换、插入</p>\n<pre><code>appendChild()removeChild()replaceChild()insertBefore() \n</code></pre><p>（3）查找</p>\n<pre><code>getElementsByTagName()getElementsByName()getElementById()\n</code></pre><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p>\n<ul>\n<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>\n</li>\n<li><p>绘画 canvas<br>用于媒介回放的 video 和 audio 元素<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除</p>\n<p>语意化更好的内容元素，比如 article、footer、header、nav、section<br>表单控件，calendar、date、time、email、url、search<br>新的技术webworker, websockt, Geolocation</p>\n</li>\n<li><p>移除的元素</p>\n</li>\n</ul>\n<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>\n<p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>\n<p>支持HTML5新标签：</p>\n<ul>\n<li><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，</p>\n<p>浏览器支持新标签后，还需要添加标签默认的样式：</p>\n</li>\n<li><p>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</p>\n</li>\n</ul>\n<p>如何区分： DOCTYPE声明\\新增的结构元素\\功能元素<br>iframe的优缺点？</p>\n<p>1.<iframe>优点：</iframe></p>\n<pre><code>解决加载缓慢的第三方内容如图标和广告等的加载问题\nSecurity sandbox\n并行加载脚本\n</code></pre><p>2.<iframe>的缺点：</iframe></p>\n<pre><code>*iframe会阻塞主页面的Onload事件；\n\n*即时内容为空，加载也需要时间\n*没有语意 \n</code></pre><p>如何实现浏览器内多个标签页之间的通信?</p>\n<p>调用localstorge、cookies等本地存储方式<br>webSocket如何兼容低浏览器？</p>\n<p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR<br>线程与进程的区别</p>\n<p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>你如何对网站的文件和资源进行优化？</p>\n<p>期待的解决方案包括：<br> 文件合并<br> 文件最小化/文件压缩<br> 使用 CDN 托管<br> 缓存的使用（多个域名来提供缓存）<br> 其他<br>请说出三种减少页面加载时间的方法。</p>\n<p>1.优化图片<br> 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br> 3.优化CSS（压缩合并css，如margin-top,margin-left…)<br> 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）<br> 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） </p>\n<p>6.减少http请求（合并文件，合并图片）。<br>你都使用哪些工具来测试代码的性能？</p>\n<p>Profiler, JSPerf（http:<br>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</p>\n<p> FOUC - Flash Of Unstyled Content 文档样式闪烁<br> <styletype=\"text css\"media=\"all\">@import”../fouc.css”;<br>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br> 解决方法简单的出奇，只要在<head>之间加入一个<link>或者<script>元素就可以了。<br>null和undefined的区别？</p>\n<p>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。<br>当声明的变量还未被初始化时，变量的默认值为undefined。<br>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。<br>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>（1）变量被声明了，但没有赋值时，就等于undefined。</p>\n<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>\n<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>\n<p>（4）函数没有返回值时，默认返回undefined。<br>null表示”没有对象”，即该处不应该有值。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。</p>\n<p>（2） 作为对象原型链的终点。<br>new操作符具体干了什么呢?</p>\n<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>   2、属性和方法被加入到 this 引用的对象中。<br>   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>\n<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);<br>JSON 的了解？</p>\n<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br>{‘age’:’12’, ‘name’:’back’}<br>js延迟加载的方式有哪些？</p>\n<p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js<br>如何解决跨域问题?</p>\n<pre><code>jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n</code></pre><p>jsonp的原理是动态插入script标签<br>具体参见：详解js跨域问题<br>documen.write和 innerHTML的区别</p>\n<p>document.write只能重绘整个页面</p>\n<p>innerHTML可以重绘页面的一部分<br>.call() 和 .apply() 的区别和作用？</p>\n<p>作用：动态改变某个类的某个方法的运行环境。<br>区别参见：JavaScript学习总结（四）function函数部分<br>哪些操作会造成内存泄漏？</p>\n<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>\n<p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）<br>详见：详解js变量、作用域及内存<br>JavaScript中的作用域与变量声明提升？</p>\n<p>详见：详解JavaScript函数模式<br>如何判断当前脚本运行在浏览器还是node环境中？</p>\n<p>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中<br>其他问题？</p>\n<p>你遇到过比较难的技术问题是？你是如何解决的？常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？页面重构怎么操作？列举IE 与其他浏览器不一样的特性？99%的网站都需要被重构是那本书上写的？什么叫优雅降级和渐进增强？<br>详见：css学习归纳总结（一）<br>WEB应用从服务器主动推送Data到客户端有那些方式？对Node的优点和缺点提出了自己的看法？<br>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>\n<p>*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。<br>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？你常用的开发工具是什么，为什么？数组去重？对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？<br>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>    1、实现界面交互<br>    2、提升用户体验<br>    3、有了Node.js，前端可以实现服务端的一些事情</p>\n<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p>\n<p> 参与项目，快速高质量完成实现效果图，精确到1px；</p>\n<p> 与团队成员，UI设计，产品经理的沟通；</p>\n<p> 做好的页面结构，页面重构和用户体验；</p>\n<p> 处理hack，兼容、写出优美的代码格式；</p>\n<p> 针对服务器的优化、拥抱最新前端技术。<br>你在现在的团队处于什么样的角色，起到了什么明显的作用？你认为怎样才是全端工程师（Full Stack developer）？介绍一个你最得意的作品吧？你的优点是什么？缺点是什么？如何管理前端团队?最近在学什么？能谈谈你未来3，5年给自己的规划吗？<br>你有哪些性能优化的方法？</p>\n<p>（看雅虎14条性能优化原则）。</p>\n<p>  （1） 减少http请求次数：CSSSprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>\n<p>  （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>\n<p>  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>\n<p>  （4） 当需要设置的样式很多时设置className而不是直接操作style。</p>\n<p>  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>\n<p>  （6） 避免使用CSSExpression（css表达式)又称Dynamic properties(动态属性)。</p>\n<p>  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。<br>http状态码有那些？分别代表是什么意思？</p>\n<p>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。<br>500-599 用于支持服务器错误。 503 – 服务不可用<br>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>\n<p> 查找浏览器缓存<br>    DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求<br>    进行HTTP协议会话<br>    客户端发送报头(请求报头)<br>    服务器回馈报头(响应报头)<br>    html文档开始下载<br>    文档树建立，根据标记请求所需指定MIME类型的文件<br>    文件显示<br>    {<br>    浏览器这边做的工作大致分为以下几步：</p>\n<pre><code>加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。\n\n解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）\n}\n</code></pre><p>平时如何管理你的项目？</p>\n<p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p>\n<pre><code>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n页面进行标注（例如 页面 模块 开始和结束）；\n\nCSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；\n\nJS 分文件夹存放 命名以该JS功能为准的英文翻译。\n\n图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 \n</code></pre><p>说说最近最流行的一些东西吧？常去哪些网站？</p>\n<p>Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。<br>网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等<br>javascript对象的几种创建方式</p>\n<p>1，工厂模式<br>2，构造函数模式<br>3，原型模式<br>4，混合构造函数和原型模式<br>5，动态原型模式<br>6，寄生构造函数模式<br>7，稳妥构造函数模式<br>javascript继承的6种方法</p>\n<p>1，原型链继承<br>2，借用构造函数继承<br>3，组合继承(原型+借用构造)<br>4，原型式继承<br>5，寄生式继承<br>6，寄生组合式继承<br>ajax过程</p>\n<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>\n<p>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>\n<p>(3)设置响应HTTP请求状态变化的函数.</p>\n<p>(4)发送HTTP请求.</p>\n<p>(5)获取异步调用返回的数据.</p>\n<p>(6)使用JavaScript和DOM实现局部刷新.<br>异步加载和延迟加载</p>\n<p>1.异步加载的方案： 动态插入script标签<br>2.通过ajax去获取js代码，然后通过eval执行<br>3.script标签上添加defer或者async属性<br>4.创建并插入iframe，让它异步执行js<br>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。<br>前端安全问题？</p>\n<pre><code>（XSS，sql注入，CSRF）\n</code></pre><p>CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。</p>\n<p><strong>完成CSRF需要两个步骤：</strong></p>\n<p>1.登陆受信任的网站A，在本地生成COOKIE</p>\n<p>2.在不登出A的情况下，或者本地COOKIE没有过期的情况下，访问危险网站B。<br>ie各版本和chrome可以并行下载多少个资源</p>\n<p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p>\n<p>Firefox，chrome也是6个<br>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</p>\n<p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量<br>grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。</p>\n<p>YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。</p>\n<p>使用方法：</p>\n<p>//压缩JS<br>java -jar yuicompressor-2.4.2.jar –type js –charset utf-8-v src.js &gt; packed.js<br>//压缩CSS<br>java -jar yuicompressor-2.4.2.jar –type css –charset utf-8-v src.css &gt; packed.css<br>Flash、Ajax各自的优缺点，在使用中如何取舍？</p>\n<p>1、Flash ajax对比<br>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。<br>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM<br>GET和POST的区别，何时使用POST？</p>\n<p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>\n<pre><code>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，\n也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n</code></pre><p>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>\n</script></head></styletype=\"text></p>","tags":[{"name":"cookies","slug":"cookies","permalink":"http://yoursite.com/tags/cookies/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"github搭建博客优点","date":"2016-07-22T07:08:32.000Z","path":"2016/07/22/my-first-blog/","raw":"---\ntitle: github搭建博客优点\ndate: 2016-07-22 15:08:32\ncategories:\ntags:\n     - 黑魔法\n     - 奇淫技巧\n---\n使用github pages服务搭建博客的好处有：\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=439915614&auto=1&height=66\"></iframe>\n\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n\n<!--more-->\n\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n6. 等等；\n\n\n\n\n","content":"<p>使用github pages服务搭建博客的好处有：</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=439915614&auto=1&height=66\"></iframe>\n\n<ol>\n<li>全是静态文件，访问速度快；</li>\n<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>\n<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>\n<li>博客内容可以轻松打包、转移、发布到其它平台；</li>\n<li>等等；</li>\n</ol>\n","tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"http://yoursite.com/tags/黑魔法/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"}]}]